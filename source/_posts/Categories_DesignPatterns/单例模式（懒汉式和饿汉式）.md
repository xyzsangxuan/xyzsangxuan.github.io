---
title: 单例模式（懒汉式和饿汉式）
date: 2020-07-06 14:01:48
tags: 
    - 单例模式
categories: 
    - 设计模式
cover: /img/cover13.jpg
top_img: /img/cover13.jpg
mathjax: false
description: 如题
---
1、时间和空间

比较上面两种写法：懒汉式是典型的时间换空间，也就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。

饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。

2、线程安全

（1）从线程安全性上讲，不加同步的懒汉式是线程不安全的，比如，有两个线程，一个是线程A，一个是线程B，它们同时调用getInstance方法，那就可能导致并发问题。如下示例：
```
public static  Singleton getInstance(){  
    if(instance == null){  
        instance = new Singleton();  
    }  
    return instance;  
} 
程序继续运行，两个线程都向前走了一步，如下：

public static  Singleton getInstance(){  
    if(instance == null){  
         instance = new Singleton();  
    }  
    return instance;  
} 
```
可能有些朋友会觉得文字描述还是不够直观，再来画个图说明一下，如图5.4所示。
![avatar](/img/20140518111853750.jpg)
 
图5.4  懒汉式单例的线程问题示意图

通过图5.4的分解描述，明显地看出，当A、B线程并发的情况下，会创建出两个实例来，也就是单例的控制在并发情况下失效了。

（2）饿汉式是线程安全的，因为虚拟机保证只会装载一次，在装载类的时候是不会发生并发的。

（3）如何实现懒汉式的线程安全呢？

当然懒汉式也是可以实现线程安全的，只要加上synchronized即可，如下：

public static synchronized Singleton getInstance(){} 
但是这样一来，会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式来实现呢？

（4）双重检查加锁

可以使用"双重检查加锁"的方式来实现，就可以既实现线程安全，又能够使性能不受到很大的影响。那么什么是"双重检查加锁"机制呢？

所谓双重检查加锁机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法过后，先检查实例是否存在，如果不存在才进入下面的同步块，这是第一重检查。进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。

双重检查加锁机制的实现会使用一个关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存,从而确保多个线程能正确的处理该变量。

看看代码可能会更加清楚些。示例代码如下：
```
public class Singleton {  
      
    private volatile static Singleton instance = null;  
    private Singleton(){  
    }  
    public static  Singleton getInstance(){  
        //先检查实例是否存在，如果不存在才进入下面的同步块  
        if(instance == null){  
            //同步块，线程安全地创建实例  
            synchronized(Singleton.class){  
                //再次检查实例是否存在，如果不存在才真正地创建实例  
                if(instance == null){  
                    instance = new Singleton();  
                }  
            }  
        }  
        return instance;  
    }  
} 
```
这种实现方式可以实现既线程安全地创建实例，而又不会对性能造成太大的影响。它只是在第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。