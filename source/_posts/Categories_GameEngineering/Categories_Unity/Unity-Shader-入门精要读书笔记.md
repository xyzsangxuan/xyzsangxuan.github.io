---
title: Unity Shader 入门精要读书笔记
date: 2021-10-20 21:33:03
tags: 
    - Shader
categories: 
    - 游戏引擎
    - Unity
    - Shader
cover: /img/cover2.png
top_img: /img/cover2.png
mathjax: true
description: Unity Shader的学习记录
keywords: Math&Shader
---
[TOC]
# 前言
实际上 Shader仅是整个渲染流程的一个子部份。不了解基础的渲染流程和基本的数学知识，想要深入学习Shader的编写石非常困难的。

# 基础
## 渲染流水线
Shader 即着色器。与之关系非常紧密的就是渲染流水线。要想入门shader，受限需要了解渲染流水线的工作流程。

渲染流水线的目的在于渲染一张二维纹理 即我们在屏幕上看到的所有效果。他的输入是一个虚拟摄像机、一些光源、一些Shader以及纹理等。

### 综述
Shader仅仅是渲染流水线中的一个环节。
#### 什么是流水线
将一个工作，分成若干个阶段，阶段间彼此互不影响。效率提升相应的若干倍。如果各阶段所用时间不同，那么整体效率为效率最低者的效率
#### 什么是渲染流水线
计算机的CPU和GPU共同完成将一系列的定点数据、纹理等信息逐步转换成人眼可以看到的图像。

效仿前人，我们将一个渲染流程分成3个阶段：
* 应用阶段(Application Stage):通常由CPU负责实现，开发者控制。任务有三：一.准备摄像机位置、视锥体、场景模型等。二.提高渲染性能进行粗粒度剔除（culling）工作。提出不可见物体。三.设置模型渲染状态。包括材质（漫反射颜色、高光反射颜色）纹理，shader等组重要的输出是渲染所需要的几何信息 即 **渲染图元(rendering primitives)** 点线面等。

* 几何阶段(Geometry Stage):这一阶段通常在GPU上进行。几何阶段最重要的就是把顶点坐标编导屏幕空间中，再交给光栅器进行处理。最后输出屏幕空间的二位顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一阶段。

* 光栅化阶段(Rasterizer Stage):yezaiGPU上进行。使用上各阶段传递的数据来产生屏幕的像素，并渲染出最终的图像。

### CPU和GPU之间的通信

#### 把数据加载导线村中

#### 设置渲染状态

#### 调用Draw Call

### GPU流水线

#### 概述
几何阶段
```
graph LR
顶点数据-->顶点着色器
顶点着色器-->曲面细分着色器
曲面细分着色器-->几何着色器
几何着色器-->裁剪
裁剪-->屏幕映射
屏幕映射-->三角形设置
style 顶点数据 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;
style 三角形设置 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;
```
光栅化阶段
```
graph LR
屏幕映射-->三角形设置

三角形设置-->三角形遍历
三角形遍历-->片元着色器
片元着色器-->逐片元操作
逐片元操作-->屏幕图像
style 屏幕映射 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;
style 屏幕图像 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;
```
顶点着色器（Vertex Shader）是完全可编程的。
曲面细分着色器（Tessellation Shader）是一个可选的着色器。
几何着色器（Geometry Shader）同样是一个可选的着色器。下一个流水线阶段是裁剪（Clipping），将不再摄像机视野内的顶点裁剪掉，并提出某些三角图元的面片。这个阶段可配置。

#### 顶点着色器


# 数学知识

我们在**笛卡尔坐标系**下进行位置、距离和角度的计算。
左手坐标系 左手法则可以指明左手坐标系的正方向 即是顺时针，右手坐标系同理。

3ds Max是右手坐标系

(1,0,0) (1,0,0)
左手坐标系和右手坐标系在绝大所述情况下不会对底层的数学运算造成影响，但是会在视觉表现上有所差异。

-10 10
##  点和矢量

 点 矢量 标量

### 矢量运算
#### 矢量和标量的乘法/除法
#### 矢量的加法和减法
#### 矢量的模
#### 单位矢量
#### 点积
任何两个矢量的点积a·b等同于b在a方向上的投影值，再乘以a的长度。
公式一：a·b = (ax,ay,az)·(bx,by,bz) = axbx+ayby+azbz

性质1：点积可结合标量乘法

(ka)·b = a·(kb) = k(a·b)

性质2：点积可结合矢量加法和剑法，和性质1类似

a·(b+c) = a·b+a·c

性质3:一个矢量和本身进行点积的结果，是该矢量的模的平方。

v·v = vxvx +vyvy+vzvz = |v|^2

公式二：a·b=|a||b|cosx

####  叉积

aXb = (ax,ay,az)X(bx,by,bz) = (aybz-azby,azbx-axbz,axby-aybx)

叉积不满足jiaohuanlv，即 axb 不等于bxa。实际上叉积满足反交换律，即 axb = -（bxa）。而且叉积不满足结合律ax(bxc)不等于 (axb)xc

叉积得到的是一个同时垂直于这两个矢量的新矢量。

公式：|axb| = |a||b|sinx

× √ ×
根号（62）

## 矩阵
性质1：矩阵乘法不满足交换律

性质2：矩阵乘法满足组结合律

### 对角矩阵

### 单位矩阵 I

### 转置矩阵 M MT

性质1：转置矩阵的转置等于原矩阵。

性质2：矩阵串接的转置，等于方向串接各个矩阵的转置
(AB)T = BTAT

### 逆矩阵 M M-1
MM-1 =  M-1M = I

一个矩阵的行列式不等于0，他就是ke'ni可逆的。

性质1：逆矩阵的您局长真就是原矩阵本身

性质2：单位矩阵的逆矩阵那就是它本身

性质3：转置矩阵的逆矩阵是逆矩阵的转置

性质4：矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵。

逆矩阵是具有几何意义的，一个矩阵可以表示一个变换，逆矩阵允许我们还原这个变换，即整个变换的反向变换。

###  正交矩阵
 
 正交是一种属性。如果一个方阵M和他的转置矩阵的乘积是单位矩阵的话，我们就说这个举矩阵是正交的。
 矩阵M是正交的 等价于：
 MMT = MTM = I


如果一个矩阵是正交的，那么他的转置矩阵和逆矩阵是一样的。

正交基  标准正交基

### 行矩阵 列矩阵

Unity中 把矢量放在矩阵的右侧，即把矢量转换成列矩阵进行计算
CBAv = (C(B(Av))

## 矩阵的几何意义：变换

三维渲染中 矩阵可视化的结果就是变换 即矩阵 = 变换

### 什么是变换
点 方向 矢量 甚至颜色

线性变换：可以保留矢量加和标量乘的变换。
f(x)+f(y) = f(x+y)

kf(x) = f(kx)

缩放是一种线性变换。例如，f(x) = 2x 可以表示一个大小为2的统一缩放 即经过变换后矢量x的模将被放大两倍。f(x)=2x是满足上面的两个条件的。同理旋转也是一种线性变换。

对一个三位矢量进行变换，那么仅仅使用3X3的举着你就可以表示所有的线性变换。

线性变换：旋转（rotation） 缩放（scale） 错切（Shear）  镜像（Mirroring也被称为reflection） 正交投影（orthographic projection）


平移变换：满足标量乘法 但不能满足矢量加法。

仿射变换： 合并线性变换和平移变换类型。仿射变换可以使用一个4x4的矩阵来表示，为此把矢量扩展到四维空间下，这就是齐次坐标空间（homogeneous space）

常见的变换种类和它们的特性
变换名称 |是线性变化| 是仿射变换| 是可逆矩阵| 是正交矩阵
---|---|---|---|---
平移矩阵|x|√|√|x
绕坐标轴旋转的旋转矩阵|√|√|√|√
绕任意轴旋转的旋转矩阵|√|√|√|√
绕坐标轴缩放的缩放矩阵|√|√|√|x
错切矩阵|√|√|√|x
镜像矩阵|√|√|√|√
正交投影矩阵|√|√|x|x
透视投影矩阵|x|x|x|x

### 齐次坐标
为了表示平移操作 我们扩展到了4x4矩阵 同时我们需要把原来的三维矢量转换成四维矢量 即齐次坐标(homogeneous coordinate)

点的齐次坐标转换：w分量设为1

方向矢量的齐次转换：w = 0

这样的设置会导致当用一个4x4矩阵对一个点进行变换时，平移、旋转、缩放都会施加于该店。但是如果用于变化你个方向矢量，平移的效果就会被忽略。


### 分解基础变换矩阵
[

]


### 平移矩阵


### 缩放矩阵

### 旋转矩阵

### 复合变换
把平移、旋转和缩放组合起来，来形成一个复杂的变换过程。
（由于使用列矩阵，因此阅读顺序是从右到左，先进行缩放变换，再进行旋转变换，最后进行评议变换。需要注意的是，变换的结果是依赖变换顺序的。根源在于矩阵的乘法不满足交换律。）

## 坐标空间

### 模型空间
模型空间（modle space 也被称为对象空间（Object space）或局部空间（local space））

### 世界空间
世界空间（world space）是 我们建立的所关心的最大的空间（相对来讲）

顶点变换的第一步就是将顶点从模型空间变换到世界空间。这个变换通常叫做模型变换（modle transform）



### 观察空间

观察空间（view space）也被称为摄像机空间（camera space）

观察空间到屏幕空间需要投影操作

顶点变换的第二步，就是将顶点从世界空间变换到观察者空间中。这个变换通常叫做观察变换。

为了得到顶点在观察空间中的位置，我们可以有两种办法。一种方法是计算观察空间的3个坐标轴在世界空间狭隘的表示，然后根据4.6.2节中讲到的方法，构建出从观察空间变换到世界空间的变换矩阵，在对该矩阵求逆。

另一种方法，即想象平移整个观察空间，让摄像机原点位于世界坐标的原点，坐标轴与世界空间中的坐标轴重合即可。
这里采用第二种思维
构造变换矩阵后 []由于观察空间使用的是右手坐标系，因此需要对z分量进行取反操作。我们可以乘以一个特殊的矩阵来得到最终的观察变换矩阵
1 0 0 0
0 1 0 0
0 0-1 0
0 0 0 0

### 裁剪空间
顶点接下来就是要从观察空间转换到裁剪空间（clip space 也被成为齐次裁剪空间）中。这个用于变换的矩阵叫做裁剪矩阵（clip matrix），也被称为投影矩阵（projection matrix）

视锥体决定需要裁剪的空间。

视锥体由六个面包围而成。这些平面也被称为裁剪平面。
视锥体有两种类型，按投影方式区分的，分别是正交投影（orthogragphic projection）、透视投影（perspective projection）。

6块裁剪平面中有两块特殊的：近裁剪平面（near clip plane）、远裁剪平面（far clip plane）决定了摄像机可以看到的深度范围。还有四个侧裁剪面。

投影矩阵有两个目的。
* 首先为投影做准备
* 对xyz份量进行缩放。直接使用w分量作为范围值判断顶点是否位于裁剪空间。
#### 透视投影
Field of View（简称FOV）属性决定敞开角度

Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的远近。

这样我们可以求出视锥体近裁剪平面的高度，也就是：

```math
nearClipPlaneHeight = 2 \cdot Near\cdot \tan{FOV \over 2}

farClipPlaneHeight = 2 \cdot Far \cdot \tan{FOV \over 2}
```
现在只有竖向的高度。同时不需要有宽度
通过宽高比确定远近平面

```math
Aspect = {nearClipPlaneWidth \over nearClipPlaneHeight}

Aspect = {farClipPlaneWidth \over farClipPlaneHeight}

```
#### 正交投影 

### 屏幕空间
将视锥体投影到屏幕空间（screen space）


法线的变换需要使用元变换矩阵的逆转置矩阵。

# 初级
## 开始Unity Shader
### 一个简单的顶点/片元着色器
#### 顶点/片元着色器的基本结构
```
Shader "MyShaderName"{
    Properties{
        //属性
    }
    SubShader{
        //针对显卡A的SubShader
        pass{
            //设置渲染状态和标签
            
            //开始CG代码片段
            CGPROGRAM
            //改代码片段的编译指令，例如
            #pragma vertex vert
            #pragma gragment frag
            
            // CG 代码写在这里
            
            ENDCG
            
            //其他设置
        }
        //其他需要的Pass
    }
    SubShader{
        //针对显卡B大的SubShader
    }
    //上述SubShader都失败后用于回调的Unity Shader
    Fallback "VertexLit"
}
```
```
//它们将告诉Unity，那些函数包含了顶点着色器的代码，那些函数包含了片元着色器的代码。
#pragma vertex vert
#pragma gragment frag
```

更通用的编译指令如下：
```
#pragma vertex name
#pragma gragment name
```
### Unity提供的内置文件和变量

### Unity提供的CG /HLSL语义
语义可以让shader知道从哪里读取数据，并把数据输出到哪里。
DirectX 10以后有了一种新的语义类型，就是·系统数值语义 以SV开头，SV代表的含义就是系统数值。

## Unity中的基础光照
### 光源
辐射度（irradiance） ：通过计算在垂直于l的单位面积上单位时间内穿过的能量来得到

在计算表面的辐射度，我们可以使用光源方向l和表面法线n之间的l夹角的余弦值来得到。
光线和物体相交的结果有两个
### 吸收和散射
散射（scattering）：散射只改变光线的方向，但不改变光线的密度和颜色
* 折射（refraction）或者投射（transmission）：
* 反射（reflection）：

高光反射（specular）：

漫反射（diffuse）：

吸收（absorption）：

### 着色（Shading）
光照模型（Lighting Model）：一个根据材质属性（如漫反射属性等）、光源信息（如光源方向、辐照度等）计算沿某个观察方向的出射度的等式。
### BRDF（Bidirectional Reflectance Distribution Function）光照模型

## 标准光照模型
标准光照模型只关心直接光照（direct light）
也就是直接从光源发射出来超射到物体表面后，经过物体表面的一次反射直接进入到摄像机的光线。基本方法是将光线分为四个部分。
* 自发光（emissive）部分：
* 高光反射（specular）部分：当光线照射到模型表面时，表面会在完全镜面反射方向散射多少辐射量。
* 漫反射（diffuse）：当光线照射到模型表面时，该表面会向每个方向散射多少辐射量。
* 环境光（ambient）部分：其他间接光照

### 环境光
```math
c_{ambient} = g_{ambient}
```

### 自发光
```math
c_{emissive} = m_{emissive}
```

### 漫反射
漫反射光照符合兰伯特定律（Lambert`s law）：漫反射的强渡与表面法线和光源方向之间夹角的余弦值成正比。计算如下。

```math
c_{diffuse} = (c_{liagnt}·m_{diffuse})max(0,n·I)
```
### 高光反射
让物体看起来有光泽。金属材质。

计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。
我们可以用Phong模型来计算高光反射的部分：

```math
c_{spscular} = (c_{light}·m_{specular})max(0,v·r)^{m_{gloss}}
```

### 逐像素或者逐顶点






