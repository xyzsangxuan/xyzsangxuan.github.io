[{"title":"游戏引擎搭建 一 入口","url":"/2021/10/24/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%90%AD%E5%BB%BA/","content":"  Github地址：Solar引擎\n序言\n2021-10-24 13:10 - 2021-10-24 13:11这一分钟 你属于我！\nEntry Point\n","categories":["游戏引擎","Solar"],"tags":["C++"]},{"title":"Unity Shader 入门精要读书笔记","url":"/2021/10/20/Unity-Shader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","content":" 前言\n实际上 Shader仅是整个渲染流程的一个子部份。不了解基础的渲染流程和基本的数学知识，想要深入学习Shader的编写石非常困难的。\n 基础\n 渲染流水线\nShader 即着色器。与之关系非常紧密的就是渲染流水线。要想入门shader，受限需要了解渲染流水线的工作流程。\n渲染流水线的目的在于渲染一张二维纹理 即我们在屏幕上看到的所有效果。他的输入是一个虚拟摄像机、一些光源、一些Shader以及纹理等。\n 综述\nShader仅仅是渲染流水线中的一个环节。\n 什么是流水线\n将一个工作，分成若干个阶段，阶段间彼此互不影响。效率提升相应的若干倍。如果各阶段所用时间不同，那么整体效率为效率最低者的效率\n 什么是渲染流水线\n计算机的CPU和GPU共同完成将一系列的定点数据、纹理等信息逐步转换成人眼可以看到的图像。\n效仿前人，我们将一个渲染流程分成3个阶段：\n\n\n应用阶段(Application Stage):通常由CPU负责实现，开发者控制。任务有三：一.准备摄像机位置、视锥体、场景模型等。二.提高渲染性能进行粗粒度剔除（culling）工作。提出不可见物体。三.设置模型渲染状态。包括材质（漫反射颜色、高光反射颜色）纹理，shader等组重要的输出是渲染所需要的几何信息 即 渲染图元(rendering primitives) 点线面等。\n\n\n几何阶段(Geometry Stage):这一阶段通常在GPU上进行。几何阶段最重要的就是把顶点坐标编导屏幕空间中，再交给光栅器进行处理。最后输出屏幕空间的二位顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一阶段。\n\n\n光栅化阶段(Rasterizer Stage):yezaiGPU上进行。使用上各阶段传递的数据来产生屏幕的像素，并渲染出最终的图像。\n\n\n CPU和GPU之间的通信\n 把数据加载导线村中\n 设置渲染状态\n 调用Draw Call\n GPU流水线\n 概述\n几何阶段\ngraph LR顶点数据--&gt;顶点着色器顶点着色器--&gt;曲面细分着色器曲面细分着色器--&gt;几何着色器几何着色器--&gt;裁剪裁剪--&gt;屏幕映射屏幕映射--&gt;三角形设置style 顶点数据 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;style 三角形设置 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;\n光栅化阶段\ngraph LR屏幕映射--&gt;三角形设置三角形设置--&gt;三角形遍历三角形遍历--&gt;片元着色器片元着色器--&gt;逐片元操作逐片元操作--&gt;屏幕图像style 屏幕映射 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;style 屏幕图像 fill:#fff,stroke:#020,stroke-width:1px,stroke-dasharray:10,10;\n顶点着色器（Vertex Shader）是完全可编程的。\n曲面细分着色器（Tessellation Shader）是一个可选的着色器。\n几何着色器（Geometry Shader）同样是一个可选的着色器。下一个流水线阶段是裁剪（Clipping），将不再摄像机视野内的顶点裁剪掉，并提出某些三角图元的面片。这个阶段可配置。\n 顶点着色器\n 数学知识\n我们在笛卡尔坐标系下进行位置、距离和角度的计算。\n左手坐标系 左手法则可以指明左手坐标系的正方向 即是顺时针，右手坐标系同理。\n3ds Max是右手坐标系\n(1,0,0) (1,0,0)\n左手坐标系和右手坐标系在绝大所述情况下不会对底层的数学运算造成影响，但是会在视觉表现上有所差异。\n-10 10\n 点和矢量\n点 矢量 标量\n 矢量运算\n 矢量和标量的乘法/除法\n 矢量的加法和减法\n 矢量的模\n 单位矢量\n 点积\n任何两个矢量的点积a·b等同于b在a方向上的投影值，再乘以a的长度。\n公式一：a·b = (ax,ay,az)·(bx,by,bz) = axbx+ayby+azbz\n性质1：点积可结合标量乘法\n(ka)·b = a·(kb) = k(a·b)\n性质2：点积可结合矢量加法和剑法，和性质1类似\na·(b+c) = a·b+a·c\n性质3:一个矢量和本身进行点积的结果，是该矢量的模的平方。\nv·v = vxvx +vyvy+vzvz = |v|^2\n公式二：a·b=|a||b|cosx\n 叉积\naXb = (ax,ay,az)X(bx,by,bz) = (aybz-azby,azbx-axbz,axby-aybx)\n叉积不满足jiaohuanlv，即 axb 不等于bxa。实际上叉积满足反交换律，即 axb = -（bxa）。而且叉积不满足结合律ax(bxc)不等于 (axb)xc\n叉积得到的是一个同时垂直于这两个矢量的新矢量。\n公式：|axb| = |a||b|sinx\n× √ ×\n根号（62）\n 矩阵\n性质1：矩阵乘法不满足交换律\n性质2：矩阵乘法满足组结合律\n 对角矩阵\n 单位矩阵 I\n 转置矩阵 M MT\n性质1：转置矩阵的转置等于原矩阵。\n性质2：矩阵串接的转置，等于方向串接各个矩阵的转置\n(AB)T = BTAT\n 逆矩阵 M M-1\nMM-1 =  M-1M = I\n一个矩阵的行列式不等于0，他就是ke’ni可逆的。\n性质1：逆矩阵的您局长真就是原矩阵本身\n性质2：单位矩阵的逆矩阵那就是它本身\n性质3：转置矩阵的逆矩阵是逆矩阵的转置\n性质4：矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵。\n逆矩阵是具有几何意义的，一个矩阵可以表示一个变换，逆矩阵允许我们还原这个变换，即整个变换的反向变换。\n 正交矩阵\n正交是一种属性。如果一个方阵M和他的转置矩阵的乘积是单位矩阵的话，我们就说这个举矩阵是正交的。\n矩阵M是正交的 等价于：\nMMT = MTM = I\n如果一个矩阵是正交的，那么他的转置矩阵和逆矩阵是一样的。\n正交基  标准正交基\n 行矩阵 列矩阵\nUnity中 把矢量放在矩阵的右侧，即把矢量转换成列矩阵进行计算\nCBAv = (C(B(Av))\n 矩阵的几何意义：变换\n三维渲染中 矩阵可视化的结果就是变换 即矩阵 = 变换\n 什么是变换\n点 方向 矢量 甚至颜色\n线性变换：可以保留矢量加和标量乘的变换。\nf(x)+f(y) = f(x+y)\nkf(x) = f(kx)\n缩放是一种线性变换。例如，f(x) = 2x 可以表示一个大小为2的统一缩放 即经过变换后矢量x的模将被放大两倍。f(x)=2x是满足上面的两个条件的。同理旋转也是一种线性变换。\n对一个三位矢量进行变换，那么仅仅使用3X3的举着你就可以表示所有的线性变换。\n线性变换：旋转（rotation） 缩放（scale） 错切（Shear）  镜像（Mirroring也被称为reflection） 正交投影（orthographic projection）\n平移变换：满足标量乘法 但不能满足矢量加法。\n仿射变换： 合并线性变换和平移变换类型。仿射变换可以使用一个4x4的矩阵来表示，为此把矢量扩展到四维空间下，这就是齐次坐标空间（homogeneous space）\n常见的变换种类和它们的特性\n\n\n\n变换名称\n是线性变化\n是仿射变换\n是可逆矩阵\n是正交矩阵\n\n\n\n\n平移矩阵\nx\n√\n√\nx\n\n\n绕坐标轴旋转的旋转矩阵\n√\n√\n√\n√\n\n\n绕任意轴旋转的旋转矩阵\n√\n√\n√\n√\n\n\n绕坐标轴缩放的缩放矩阵\n√\n√\n√\nx\n\n\n错切矩阵\n√\n√\n√\nx\n\n\n镜像矩阵\n√\n√\n√\n√\n\n\n正交投影矩阵\n√\n√\nx\nx\n\n\n透视投影矩阵\nx\nx\nx\nx\n\n\n\n 齐次坐标\n为了表示平移操作 我们扩展到了4x4矩阵 同时我们需要把原来的三维矢量转换成四维矢量 即齐次坐标(homogeneous coordinate)\n点的齐次坐标转换：w分量设为1\n方向矢量的齐次转换：w = 0\n这样的设置会导致当用一个4x4矩阵对一个点进行变换时，平移、旋转、缩放都会施加于该店。但是如果用于变化你个方向矢量，平移的效果就会被忽略。\n 分解基础变换矩阵\n[\n]\n 平移矩阵\n 缩放矩阵\n 旋转矩阵\n 复合变换\n把平移、旋转和缩放组合起来，来形成一个复杂的变换过程。\n（由于使用列矩阵，因此阅读顺序是从右到左，先进行缩放变换，再进行旋转变换，最后进行评议变换。需要注意的是，变换的结果是依赖变换顺序的。根源在于矩阵的乘法不满足交换律。）\n 坐标空间\n 模型空间\n模型空间（modle space 也被称为对象空间（Object space）或局部空间（local space））\n 世界空间\n世界空间（world space）是 我们建立的所关心的最大的空间（相对来讲）\n顶点变换的第一步就是将顶点从模型空间变换到世界空间。这个变换通常叫做模型变换（modle transform）\n 观察空间\n观察空间（view space）也被称为摄像机空间（camera space）\n观察空间到屏幕空间需要投影操作\n顶点变换的第二步，就是将顶点从世界空间变换到观察者空间中。这个变换通常叫做观察变换。\n为了得到顶点在观察空间中的位置，我们可以有两种办法。一种方法是计算观察空间的3个坐标轴在世界空间狭隘的表示，然后根据4.6.2节中讲到的方法，构建出从观察空间变换到世界空间的变换矩阵，在对该矩阵求逆。\n另一种方法，即想象平移整个观察空间，让摄像机原点位于世界坐标的原点，坐标轴与世界空间中的坐标轴重合即可。\n这里采用第二种思维\n构造变换矩阵后 []由于观察空间使用的是右手坐标系，因此需要对z分量进行取反操作。我们可以乘以一个特殊的矩阵来得到最终的观察变换矩阵\n1 0 0 0\n0 1 0 0\n0 0-1 0\n0 0 0 0\n 裁剪空间\n顶点接下来就是要从观察空间转换到裁剪空间（clip space 也被成为齐次裁剪空间）中。这个用于变换的矩阵叫做裁剪矩阵（clip matrix），也被称为投影矩阵（projection matrix）\n视锥体决定需要裁剪的空间。\n视锥体由六个面包围而成。这些平面也被称为裁剪平面。\n视锥体有两种类型，按投影方式区分的，分别是正交投影（orthogragphic projection）、透视投影（perspective projection）。\n6块裁剪平面中有两块特殊的：近裁剪平面（near clip plane）、远裁剪平面（far clip plane）决定了摄像机可以看到的深度范围。还有四个侧裁剪面。\n投影矩阵有两个目的。\n\n首先为投影做准备\n对xyz份量进行缩放。直接使用w分量作为范围值判断顶点是否位于裁剪空间。\n\n 透视投影\nField of View（简称FOV）属性决定敞开角度\nClipping Planes中的Near和Far参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的远近。\n这样我们可以求出视锥体近裁剪平面的高度，也就是：\nnearClipPlaneHeight = 2 \\cdot Near\\cdot \\tan&#123;FOV \\over 2&#125;farClipPlaneHeight = 2 \\cdot Far \\cdot \\tan&#123;FOV \\over 2&#125;\n现在只有竖向的高度。同时不需要有宽度\n通过宽高比确定远近平面\nAspect = &#123;nearClipPlaneWidth \\over nearClipPlaneHeight&#125;Aspect = &#123;farClipPlaneWidth \\over farClipPlaneHeight&#125;\n 正交投影\n 屏幕空间\n将视锥体投影到屏幕空间（screen space）\n法线的变换需要使用元变换矩阵的逆转置矩阵。\n 初级\n 开始Unity Shader\n 一个简单的顶点/片元着色器\n 顶点/片元着色器的基本结构\nShader &quot;MyShaderName&quot;&#123;    Properties&#123;        //属性    &#125;    SubShader&#123;        //针对显卡A的SubShader        pass&#123;            //设置渲染状态和标签                        //开始CG代码片段            CGPROGRAM            //改代码片段的编译指令，例如            #pragma vertex vert            #pragma gragment frag                        // CG 代码写在这里                        ENDCG                        //其他设置        &#125;        //其他需要的Pass    &#125;    SubShader&#123;        //针对显卡B大的SubShader    &#125;    //上述SubShader都失败后用于回调的Unity Shader    Fallback &quot;VertexLit&quot;&#125;\n//它们将告诉Unity，那些函数包含了顶点着色器的代码，那些函数包含了片元着色器的代码。#pragma vertex vert#pragma gragment frag\n更通用的编译指令如下：\n#pragma vertex name#pragma gragment name\n Unity提供的内置文件和变量\n Unity提供的CG /HLSL语义\n语义可以让shader知道从哪里读取数据，并把数据输出到哪里。\nDirectX 10以后有了一种新的语义类型，就是·系统数值语义 以SV开头，SV代表的含义就是系统数值。\n Unity中的基础光照\n 光源\n辐射度（irradiance） ：通过计算在垂直于l的单位面积上单位时间内穿过的能量来得到\n在计算表面的辐射度，我们可以使用光源方向l和表面法线n之间的l夹角的余弦值来得到。\n光线和物体相交的结果有两个\n 吸收和散射\n散射（scattering）：散射只改变光线的方向，但不改变光线的密度和颜色\n\n折射（refraction）或者投射（transmission）：\n反射（reflection）：\n\n高光反射（specular）：\n漫反射（diffuse）：\n吸收（absorption）：\n 着色（Shading）\n光照模型（Lighting Model）：一个根据材质属性（如漫反射属性等）、光源信息（如光源方向、辐照度等）计算沿某个观察方向的出射度的等式。\n BRDF（Bidirectional Reflectance Distribution Function）光照模型\n 标准光照模型\n标准光照模型只关心直接光照（direct light）\n也就是直接从光源发射出来超射到物体表面后，经过物体表面的一次反射直接进入到摄像机的光线。基本方法是将光线分为四个部分。\n\n自发光（emissive）部分：\n高光反射（specular）部分：当光线照射到模型表面时，表面会在完全镜面反射方向散射多少辐射量。\n漫反射（diffuse）：当光线照射到模型表面时，该表面会向每个方向散射多少辐射量。\n环境光（ambient）部分：其他间接光照\n\n 环境光\nc_&#123;ambient&#125; = g_&#123;ambient&#125;\n 自发光\nc_&#123;emissive&#125; = m_&#123;emissive&#125;\n 漫反射\n漫反射光照符合兰伯特定律（Lambert`s law）：漫反射的强渡与表面法线和光源方向之间夹角的余弦值成正比。计算如下。\nc_&#123;diffuse&#125; = (c_&#123;liagnt&#125;·m_&#123;diffuse&#125;)max(0,n·I)\n 高光反射\n让物体看起来有光泽。金属材质。\n计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。\n我们可以用Phong模型来计算高光反射的部分：\nc_&#123;spscular&#125; = (c_&#123;light&#125;·m_&#123;specular&#125;)max(0,v·r)^&#123;m_&#123;gloss&#125;&#125;\n 逐像素或者逐顶点\n","categories":["游戏引擎","Unity","Shader"],"tags":["Shader"]},{"title":"[Unity资源]那些年我用过的那些资源","url":"/2021/05/26/Unity%E8%B5%84%E6%BA%90-%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E8%B4%AD%E4%B9%B0%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E8%B5%84%E6%BA%90/","content":" 1.Stand Assets\n作为刚开始学习Unity时重要的起步资源，里面的东西远超想象的丰富，很多资源都可以单独拿出来进行二次创作\n 2.PUN2 （Exit Games）\n这是一款用于开发网络游戏进行同步的工具，效率是超过Unity自带的网络开发工具的。\n 3.DOTween Pro（Demigiant）\n这是款几乎Unity开发必备的插件了。有自己的接口可以实现一些细腻的UI动画。\n 4.Dynamic Bone（Will hong）\n这是一款用于模拟动态骨骼的插件，比如尾巴 胸这类的复合动力学的骨骼运动。\n 5.Enviro - Sky and Weather（Hendrik haupt）\n这个用于模拟各种复杂的天气变化，是一套成熟的可以在游戏中运用的天气插件。\n 6.Behavior Designer（Opsive）\n行为树插件，在中小游戏的AI行为控制上极为方便。\n 7.Third Person Controller（Opsive）\n第三人称控制器，一款极为强大的控制器，如果能把这款控制器吃透，那在第三人称控制上基本上就没有问题了。\n 8.Mesh Effects（Kripto289）\n各种酷炫的粒子特效，无论是用来学习和直接使用都极为优秀\n 9.Magic Slashes FX（ORDOSS）\n同样酷炫的粒子特效，无论是用来学习和直接使用都极为优秀\n 10.Animal Controller（MALBERS ANIMATIONS）\nAnimal Controller (AC) 是一款动画框架控制器，适用于任何动物或人形角色的根运动或原地运动。\n“AC 是适用于我的所有资源的基础控制器，但也可以用于商店内的其他任何资源。\n这款控制器从零开始打造，经过 3 年多的锤炼，借助流畅的模块化控制器，令我的资源更加卓越出众。”\n 11.Poly Art Animals Forest Set（MALBERS ANIMATIONS）\n里面包含众多的lowpoly动物模型。可以用于广发的使用\n 12.Low Poly Animated People（polyperfect）\n超过一百个带动画和 Wander Script 的绑定低多边形角色。从动作英雄到僵尸。适用于任何类型的游戏。\n 13.Low Poly Animated Animals（polyperfect）\n高品质低模动物，配有惊人的动画、演示场景、多种纹理、声音和游荡脚本。\n 14.Odin\n","categories":["游戏引擎","Unity"],"tags":["资源"]},{"title":"开发一款移动设备上运行的2D游戏","url":"/2020/10/29/%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%842D%E6%B8%B8%E6%88%8F/","content":" Unit 1 Asset\n Section 1 Create Project 创建项目\n Section 2 Prepare 准备工作\n Section 3 Setup Assets 资源设置\n下载并导入素材，切割素材，设置素材的参数\n Unit 2 Build Your Level\n Section 1 Use Tilemap 使用Tilemap瓦片地图\n使用Tilemap，导入瓦片图片信息并绘制场景。\n Section 2 Rule Tile 规则瓦片\n安装 Unity 官方 2D-Extra 扩展包\nhttps://github.com/Unity-Technologies/2d-extras\nhttps://github.com/Unity-Technologies/2d-extras.git#master\n Section 3 Tilemap Collider 瓦片碰撞器\n瓦片地图碰撞器，了解 Tilemap Collider 2D 和 Composite Collider 的使用方法。\n Section 4 Other Objects 其他物体\n创建场景中的其他物体，设置 刚体 / 碰撞体 / Sorting Layer\n Section 5 Physics 2D &amp; Prefab 2D物理及预制体\n项目物理碰撞关系设置。Prefab 预制体的使用\n Unit 3 Create Player\n Section 1 Setup Player 创建玩家\n设置 Player 必要的组件，调整各项组件的参数。设置碰撞体大小和碰撞关系。\n Section 2 Movement 基本的移动\n通过代码让 Player 可以移动。Input Manager 使用方法。反转人物\n Section 3 Jump 跳跃\nUpdate 和 FixedUpdate 的使用方法。地面物理检测 Physics2D 的函数方法。OnDrawGizmos 可视化的范围调整。\n Unit 4 Animation\n Section 1 Setup Animation 设置动画\nAnimation 制作 2D Spite 帧动画。制作多个需要的动画片段。\n Section 2 Animator States 动画控制器状态\n学习动画状态机的切换方法。设置参数和条件。使用代码控制切换动画。\n Section 3 Jump VFX 跳跃的特效\n制作 跳跃 / 落地 的帧动画特效。代码控制播放的时机。碰撞关系。\n Unit 5 Create Bomb\n Section 1 Setup Bomb 创建炸弹\n创建炸弹，添加必要的组件。调整碰撞关系。创建三种状态动画。\n Section 2 Bomb Explosion 炸弹爆炸效果\n创建 Animation Event 调用的函数方法实现爆炸效果。通过 Collider2D[] 获得范围内物体数组，实现炸开弹飞效果。\n Unit 6 Create Enemy Scripts &amp; AI\n Section 1 Setup Basic Enemy 设置基本敌人\n创建基本敌人 Cucumber 黄瓜怪。设置帧动画。添加 碰撞体 / 刚体。设置碰撞图层，调整碰撞关系。\n Section 2 More Elements 更多的组件\n设置巡逻点。添加设置攻击检测范围。调整 Check Area 碰撞图层和关系。\n Section 3 Basic Methods 基本函数方法\n创建 Enemy 代码中的基本函数方法。实现 巡逻 / 移动  / 反转 / 添加攻击列表的方法。学习 List&lt;&gt; 的使用。\n Section 4 Inheritance 继承\n创建单独的 Cucumber 代码并继承 Enemy 基类。学习 virtual 函数方法如何在子类当中 override 重写。调整代码和参数。\n Section 5 Finite States Machine 有限状态机\n了解 FSM 状态机的概念 / 抽象类概念 / 抽象函数方法。用抽象类继承创建2个敌人AI状态：PatrolState / AttackState。\n Section 6 Animator States 动画状态机\n在 Animator 窗口当中，使用多个 Layer 来控制管理多种动画状态。并且通过代码脚本来控制动画的切换。\n Section 7 Switch Attack Target 切换攻击目标\n从供给列表中找到离自己最近的作为目标，并且判断目标的 Tag 是 Player 或者 Bomb 来执行不同的攻击方式。\n Section 8 Attack Action 攻击方式\n创建攻击有关的变量，实现 AttackAction 和 SkillAction 两个函数方法。判断攻击距离与攻击间隔同时满足条件的情况，采取相应的行动。\n Section 9 Hit Point 打击点\n创建攻击点 Hit Point 录制动画实现攻击 Player 的方法。创建 HitPoint 代码脚本。\n Section 10 Skill Action 技能攻击方式\n通过实际创建 Cucumber 的吹灭炸弹特殊技能，了解当敌人的攻击目标是炸弹的时候，如何采取特殊技能效果。\n Section 11 Interface：IDamageable 创建接口\n了解学习 Interface 接口的概念，通过创建 1 个接口来实现访问所有继承这个接口的代码脚本。轻松实现炸弹爆炸让周围的人物都有受到伤害的效果。\n Section 12 Player Get Hit 玩家获得伤害\n通过 IDamageable 接口实现玩家受伤，并且受伤动画播放期间短暂无敌。创建敌人警示标示，学习 协程 的使用方法。\n Unit 7 Skill Action for Each Enemies\n Section 1 Bald Pirate 光头海盗\n光头海盗的特殊技能：踢炸弹。HitPoint 代码添加弹开效果。\n Section 2 Big Guy 大块头\n实现大块头拾取炸弹并扔向玩家的方法。添加 Animation Event 设置 PickUp Point。\n Section 3 Captain 舰长\n实现粉色船长看见炸弹反跑。学习利用 Sprite Renderer 组件的 FilpX 参数实现翻转。\n Section 4 Whale 鲸鱼\n添加 Animation Event 实现吞灭炸弹。趣味添加吞下炸弹体积变大。\n Unit 8 User Interface\n Section 1 Create Canvas 创建画布\n了解基本 UGUI 的使用方法。添加 Player Health Bar 并设置 Canvas 的自动缩放。\n Section 2 Update Health 更新生命值\n创建 UIManager 代码学习单例模式。获得玩家血量，并实时更新 UI 血量显示。\n Section 3 Pause Menu 暂停菜单\n创建暂停菜单，学习 Button 组件的用法。通过代码 暂停 / 恢复游戏。\n Section 4 Boss Health Bar Boss血条\n学习 Slider 组件用法。创建 Boss 血条获得实时更新。\n Unit 9 Game Manager\n Section 1 Game Over 游戏结束画面\n创建 GameManager 代码脚本，生成单例。连接 Player 的状态，全局控制游戏的结束。添加 GameOver Panel 实现死亡弹出菜单重新开始游戏。\n Section 2 Way to the Next Room 通往下一关\n学习如何使用 Platform Effector 组件创建单项平台。创建 Door 入口和出口并创建代码。实现消灭所有敌人后开门的动画，Player 进入触发范围跳转下一场景。观察者模式的使用。\n Section 3 Save Data 保存数据\n学习了解 PlayerPrafs 的用法。保存 Player 的血量延续到下一关。在过关时保存数据。\n Section 4 Fix bugs 调整bugs\n调整一些代码的执行顺序，进一步更改观察者模式的代码设计方法。创建 Main Menu。\n Section 5 Load Game 加载游戏进度\n实现保存游戏场景，让玩家可以延续之前的游戏进度。Main Menu 各种 Button 的函数方法实现。\n Unit 10 Build for Mobile &amp; Monetization\n Section 1 Mobile Platform Control 移动平台控制方法\n下载使用 Asset Store 当中 Joystick 插件，创建屏幕横向控制器，创建按钮实现跳跃和攻击时放炸弹。重新调整代码配合 Button 的 On Click Event。\n Section 2 Build and Run 生成并运行\n分别学习如何生成 Android 和 iOS 平台，注意事项。Xcode 基本使用方法。真机测试。\n Section 3 Prepare for Unity Ads 为Unity广告做好准备\nAdvertisement package 介绍安装。Dashboard 网页端创建项目准备工作。Unity 编辑器中启动 Service 并连接到项目，打开 Ads。\n Section 4 Watch Ads 观看广告\n学习查看 API 手册的方法，实现播放奖励广告。代码控制播放广告后获得广告收益。真机操作和注意事项。\nPS.--------------------------------更新------------------------------\n\n\n泛型单例基类 ：目的是当项目量级增加时，减少重复代码\n\n\n事件中心：目的是通过观察者模式监听事件，减少Bug和梳理清晰结构\n\n\nMono工具类：目的是减少Monobehaviour的继承，优化性能，统一提供帧数更新和协程的方法\n\n\n资源加载器：统一提供同步和异步加载的方法，针对复杂情况的私人定制\n\n\n缓存池：提升重复大量object出现时的性能\n\n\n场景切换模块：统一提供同步和异步场景切换的方法，依旧是视情况而定制\n\n\n音乐音效模块：提供统一的音乐，音效控制方法\n\n\nUI 管理模块：方便管理所有显示的面板，提供给外部 显示和隐藏等接口\n\n\n广告管理模块：提前准备广告，避免加载的不及时\n\n\nPS.--------------------------------更新------------------------------\n\n\n配置表：方便大量的角色，npc，地图等的编辑\n\n\n时间线：  目前是在动画上添加事件，时间线的目的舍弃手动在动画固定帧添加事件，而是通过代码定制\n\n\n定时器管理器：目的是方便定时器的实例和管理\n\n\n编辑器扩展：自定义编辑引擎的一些功能自用\n\n\n对话框系统：可以较为方便的为每个对话npc设置对话\n\n\n随机地图：增加游戏可玩性，随机NPC ，\n\n\n背包系统：增加可玩性，持续性\n\n\nAssetBundles热更新系统：\n接下来的工作：\n装备栏、技能栏，人物成长，怪物强度成长\n设置记录过去和未来的爬塔层数\n剧情\n配置表（是否可替代）\n联机\n\n\n","categories":["游戏引擎","Unity"],"tags":["Unity2D"]},{"title":"单例模式（懒汉式和饿汉式）","url":"/2020/07/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F%E5%92%8C%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%89/","content":"1、时间和空间\n比较上面两种写法：懒汉式是典型的时间换空间，也就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。\n饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。\n2、线程安全\n（1）从线程安全性上讲，不加同步的懒汉式是线程不安全的，比如，有两个线程，一个是线程A，一个是线程B，它们同时调用getInstance方法，那就可能导致并发问题。如下示例：\npublic static  Singleton getInstance()&#123;      if(instance == null)&#123;          instance = new Singleton();      &#125;      return instance;  &#125; 程序继续运行，两个线程都向前走了一步，如下：public static  Singleton getInstance()&#123;      if(instance == null)&#123;           instance = new Singleton();      &#125;      return instance;  &#125; \n可能有些朋友会觉得文字描述还是不够直观，再来画个图说明一下，如图5.4所示。\n\n图5.4  懒汉式单例的线程问题示意图\n通过图5.4的分解描述，明显地看出，当A、B线程并发的情况下，会创建出两个实例来，也就是单例的控制在并发情况下失效了。\n（2）饿汉式是线程安全的，因为虚拟机保证只会装载一次，在装载类的时候是不会发生并发的。\n（3）如何实现懒汉式的线程安全呢？\n当然懒汉式也是可以实现线程安全的，只要加上synchronized即可，如下：\npublic static synchronized Singleton getInstance(){}\n但是这样一来，会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式来实现呢？\n（4）双重检查加锁\n可以使用&quot;双重检查加锁&quot;的方式来实现，就可以既实现线程安全，又能够使性能不受到很大的影响。那么什么是&quot;双重检查加锁&quot;机制呢？\n所谓双重检查加锁机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法过后，先检查实例是否存在，如果不存在才进入下面的同步块，这是第一重检查。进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。\n双重检查加锁机制的实现会使用一个关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存,从而确保多个线程能正确的处理该变量。\n看看代码可能会更加清楚些。示例代码如下：\npublic class Singleton &#123;            private volatile static Singleton instance = null;      private Singleton()&#123;      &#125;      public static  Singleton getInstance()&#123;          //先检查实例是否存在，如果不存在才进入下面的同步块          if(instance == null)&#123;              //同步块，线程安全地创建实例              synchronized(Singleton.class)&#123;                  //再次检查实例是否存在，如果不存在才真正地创建实例                  if(instance == null)&#123;                      instance = new Singleton();                  &#125;              &#125;          &#125;          return instance;      &#125;  &#125; \n这种实现方式可以实现既线程安全地创建实例，而又不会对性能造成太大的影响。它只是在第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。\n","categories":["设计模式"],"tags":["单例模式"]},{"title":"单例模式（以C#为例双检锁）","url":"/2020/07/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BB%A5C-%E4%B8%BA%E4%BE%8B%EF%BC%89/","content":" 前言\n\n设计模式（Design pattern），提供了在软件开发过程中面临的一些问题的最佳解决方案，是开发者必修的一门课程。主要分创建型模式、结构型模式和行为型模式。其中接下来我们要写的是单例模式，属于创建型模式。\n单例模式，顾名思义就是只有一个实例，并且她自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。主要有五种实现方式：懒汉式、饿汉式、双检锁、静态内部类、枚举\n\n 双检锁\nusing System;using System.Collections.Generic;/// &lt;summary&gt;/// 适用于在多线程的情况下保证只有一个实例化对象的情况，例如银行的操作系统/// &lt;/summary&gt;namespace DoubleLockInstance&#123;\t//----------------------------------\t// 双重锁定单例\tpublic sealed class Singleton\t&#123;\t\t// 定义一个类对象，用于内部实现\t\tprivate static Singleton myInstance; \t\t// readonly   -   这个成员只能在“类初始化”时赋值  ,所谓的类初始化，就是直接在类里面初始化\t\t// 变量标记为 readonly，第一次引用类的成员时创建实例\t\tprivate static readonly object lockRoot = new object (); \t\t// 设置构造方法为私有，这样就不能在外部实例化类对象了\t\tprivate Singleton ()\t\t&#123;\t\t&#125; \t\t// 实例化对象的方法\t\tpublic static Singleton GetInstance ()\t\t&#123;\t\t\t// 外部不能实例化对象，但是能调用类里面的静态方法\t\t\t// 外部需要调用这个方法来使用类对象，如果对象不存在就创建\t\t\t// 这里面使用两个判断是否为null的原因是，我们不需要每次都对实例化的语句进行加锁，只有当对象不存在的时候加锁就可以了\t\t\tif (myInstance == null) &#123;\t\t\t\t// 锁定的作用就是为了保证当多线程同时执行这句代码的时候保证对象的唯一性\t\t\t\t// 锁定会让同时执行这段代码的线程排队执行\t\t\t\t// lock里面需要用一个已经存在的对象来判断，所以不能使用myInstance\t\t\t\tlock (lockRoot) &#123;\t\t\t\t\t// 这里还需要一个判断的原因是，如果多线程都通过了外层的判断进行排队\t\t\t\t\t// 那将会实例化多个对象出来，所以这里还需要进行一次判断，保证线程的安全\t\t\t\t\tif (myInstance == null) &#123;\t\t\t\t\t\tmyInstance = new Singleton ();\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn myInstance;\t\t&#125;\t&#125;&#125;\n此实现是线程安全的。线程取消对共享对象的锁定，然后在创建实例之前检查是否已创建实例。这会解决内存屏障问题（因为锁定确保在获取锁之后逻辑上发生所有读取，并且解锁确保在锁定释放之前逻辑上发生所有写入）并确保只有一个线程将创建实例（仅限于一次只能有一个线程可以在代码的那一部分中——当第二个线程进入它时，第一个线程将创建实例，因此表达式将计算为false）。不幸的是，每次请求实例时都会获得锁定，因此性能会受到影响。\n请注意，我没有像这个实现的某些版本那样锁定typeof(Singleton)，而是锁定了类私有的静态变量的值。锁定其他类可以访问和锁定的对象（例如类型）会导致性能问题甚至死锁。这是我的风格偏好——只要有可能，只锁定专门为锁定目的而创建的对象，或者为了特定目的（例如，等待/触发队列）而锁定的文档。通常这些对象应该是它们所使用的类的私有对象。这有助于使编写线程安全的应用程序变得更加容易。\n 泛型双检锁\nusing System;using System.Collections.Generic;/// &lt;summary&gt;/// 单例模式基类模块/// 需要具备：/// 1.C#中 泛型的知识/// 2.设计模式中 单例模式的知识/// 3.多线程时加双锁/// &lt;/summary&gt;namespace DoubleLockInstance&#123;\t//----------------------------------\t// 双重锁定单例\tpublic sealed class Singleton&lt;T&gt; where T:new()//添加泛型约束—T必须要public的无参构造函数new()才能作为i参数传进来\t&#123;\t\t// 定义一个类对象，用于内部实现\t\tprivate static T myInstance; \t\t// readonly   -   这个成员只能在“类初始化”时赋值  ,所谓的类初始化，就是直接在类里面初始化\t\t// 变量标记为 readonly，第一次引用类的成员时创建实例\t\tprivate static readonly object lockRoot = new object (); \t\t// 设置构造方法为私有，这样就不能在外部实例化类对象了\t\tprivate T ()\t\t&#123;\t\t&#125; \t\t// 实例化对象的方法\t\tpublic static T GetInstance ()\t\t&#123;\t\t\t// 外部不能实例化对象，但是能调用类里面的静态方法\t\t\t// 外部需要调用这个方法来使用类对象，如果对象不存在就创建\t\t\t// 这里面使用两个判断是否为null的原因是，我们不需要每次都对实例化的语句进行加锁，只有当对象不存在的时候加锁就可以了\t\t\tif (myInstance == null) &#123;\t\t\t\t// 锁定的作用就是为了保证当多线程同时执行这句代码的时候保证对象的唯一性\t\t\t\t// 锁定会让同时执行这段代码的线程排队执行\t\t\t\t// lock里面需要用一个已经存在的对象来判断，所以不能使用myInstance\t\t\t\tlock (lockRoot) &#123;\t\t\t\t\t// 这里还需要一个判断的原因是，如果多线程都通过了外层的判断进行排队\t\t\t\t\t// 那将会实例化多个对象出来，所以这里还需要进行一次判断，保证线程的安全\t\t\t\t\tif (myInstance == null) &#123;\t\t\t\t\t\tmyInstance = new T ();\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn myInstance;\t\t&#125;\t&#125;&#125;\n 懒汉式\n\n在开发过程中，倘若不涉及到多线程可采用普通的懒汉式\n\npackage com.seven.exercise.testEception; /** * 懒汉式 * @author Seven * */public class SingleDemo &#123;        /**     * 私有化构造函数     */    private SingleDemo()&#123;            &#125;        private static SingleDemo singleDemo = null;        /**     * 提供获取实例的方法     * @return     */    public static SingleDemo getInstance()&#123;        if(singleDemo==null)&#123;            singleDemo = new SingleDemo();        &#125;        return singleDemo;    &#125; &#125;\nPs.如果想要更安全的单例模式，可以参照这篇博客\nc#中单例模式和双重检查锁\n","categories":["设计模式"],"tags":["单例模式"]},{"title":"Unity3d网络游戏架构-主程","url":"/2020/07/03/Unity3d%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84-%E4%B8%BB%E7%A8%8B/","content":" 前言\n     扩展:ECS 面向数据的特性可以提供大量实体,应用ECS尝试着融合成一个完整的游戏开发框架。\n     扩展:ET 框架可以简化客户端和服务端的开发，快速上线。\n 游戏基础模块\n\n\n\n游戏基础模块\n\n\n\n\n\n\n\n\nUI体系\n简单的UI体系\nLogin界面\n\n\n\n\n\n\n选角色界面\n\n\n\n\n\n\n创建角色界面\n\n\n\n\n\n核心UI体系\n战斗界面\nUI分层\n\n\n\n\n\n\n摇杆\n\n\n\n\n\n\n技能\n\n\n\n\n\n\n点击场景交互\n\n\n\n\n\n\n功能大厅\n\n\n\n\n\n\n小地图\n\n\n\n\n系统界面\n属性,背包,宠物,合成,强化等系统\n\n\n\n\n\n常用UI效果\nUI模型\n\n\n\n\n场景控制\n创建角色\n\n\n\n\n\n\n行走\n\n\n\n\n\n\n摄像机跟随\n\n\n\n\n\n\n点击场景\n\n\n\n\n\n\n场景与UI解耦\n\n\n\n\n\n\n技能状态\n\n\n\n\n\n通用模块\n配置表\n\n\n\n\n\n\n网络交互\n\n\n\n\n\n\n工具模块\n\n\n\n\n\n\n通用模块\n\n\n\n\n\n\n游戏逻辑模块\n\n\n\n\n\n\nEditor简单编写\n\n\n\n\n\n其他\n热更新\n\n\n\n\n\n\n渲染\n\n\n\n\n\n\n性能优化\n\n\n\n\n\n\n 敏捷式开发\n    游戏行业往往采用敏捷开发，用测试驱动开发（TDD）\n    从零开始 ：启动-&gt;闪屏(（Logo、防沉迷）)-&gt;检查更新-&gt;更新(重启)-&gt;公告-&gt;-&gt;登录…\n 版本控制工具\n    Git\n 环境搭建\n\nUnity package安装\n\n    Burst:p.11 1.2.0\n    Entities:p.4 0.3.0\n    Hybrid Renderer: p.4 0.3.0\n    Unity Physics:p 0.2.4\n    Universal RP:7.3.1\n 搭建基本环境\n\n泛型单例模式\n扩展类的成员函数\n游戏启动流程\n\n 游戏表格配置（角色表，Npc表，，地图表，技能表等）\n\n让策划和美术直接方便修改游戏，避免产生逻辑错误，减少程序员的工作量。\n\n    目标：能读表就读表\n\n常用配置文件格式\n\n\n\n\n常用配置文件格式\n\n\n\n\n\nExcel\n最常用的表格工具，大家都会用\n\n\nCsv\n轻量级表格数据格式。字段以“，”分隔；数据条目以“回车”分隔\n\n\nXML\n在表示树形结构方面非常方便（慢）\n\n\nJson\n最好用的格式，与程序员可以一键转换（编辑起来不方便）\n\n\n\n\n\n字符集和文件编码\n\n字符集：ASCII、Unicode…\n文件编码：ANSI、UTF-8…\n\n\n\n读取二进制文件\n\nResources.Load(“Filepath”);\nFilePath的扩展名需要时&quot;.bytes&quot;\n我们自己来解析二进制文件：\n\nvar reader = new StreamReader(tableStream,Encoding.GetEncoding(&quot;gb2312))\n\n\n反射\n\n反射的作用：运行期获取字段、类型、方法\n通俗点：使用字符串，映射出类、字段、方法。\n再直白点：OneClass.MyName;OneClas[“MyName”].一个类的名字的字符串，也可以映射到具体的类定义\n反射字段\n\n使用FieldInfo,表示类中的字段信息\nType.GetField(columName),获取字段信息。\n使用FieldInfo.FieldType获取该字段的类型。\n使用FieldInfo.SetValue给对象的字段赋值\n\n\n\n\n\n UnityEditor简单编程快速切换场景、一键打包数据\n 模拟与服务器交互（登录，创建角色，进入到游戏…\n\n\n一种简单的服务器架构\n\n\n1、定义Net类来负责所有的网络相关事宜。\n\n\n2、客户端要发消息，顶一个发消息的方法 SendCmd。\n\n\n3、客户端需要接收消息，定义一个收消息的方法Receive。\n\n\n4、需要与服务器建立连接，抽象一个服务器接口。\n\n\n5、发送一个消息（Login）。\n\n\n 角色管理RoleManager\n 使用数据库存储游戏数据\nsqlite / Mysql？\n本来我是想使用Mysql的，因为之前用过Mysql，体验也蛮好的。\n但是SQLite目前应该是更好的选择，因为轻量、稳定和易用。如果后期需要换数据库再考虑\n\n\nUnity &amp;Sqlite\n\n\n在Unity使用Sqlite、\n\n\n    使用Unity操作SQLite，需要用到三个库文件，分别是Mono.Data.Sqlite.dll和System.Data.dll和Sqlite3.dll，前两个库文件可以在unity中找到，Sqlite3.dll可以去官网下载或者本地搜索\n//我用的是这个路径2019.4.1f1\\Editor\\Data\\MonoBleedingEdge\\lib\\mono\\4.5\n\n在Unity中使用LitJson解析json文件:\n这个库需要找资源，找到LitJson.dll后将它放在Assets文件夹下，在脚本中使用using引入即可\n\n 脱离MonoBehaviour自己驱动游戏逻辑\n NavMesh寻路；指定目标行走\n 计时器Timer\n UIManager\n 摄像机跟随\n 战斗场景UI管理\n 摇杆控制实现\n 点击场景控制实现\n\n 通过Npc跳转场景\n Dialog管理\n 功能大厅，角色属性界面实现（抽象UIModel）\n 选中Npc实现\n\nNpc头像框\n下拉列表\n访问Npc，自动走打到Npc附近再触发访问\n\n AI状态机\n\n感知（周围生物，区分敌友）\n决策（大脑，根据感知系统的信息，决定具体要做什么）\n行动（四肢\n如果自己实现的可以满足要求，则使用自己创建的，但是合理利用一款不错的插件可以大幅提升开发效率\n\n 技能UI面板\n\n技能千奇百怪，需求不明，涉及多个模块、耦合性高，对象间交互，模块间交互，数据间交互，可以和任何模块交互\n技能分类：单体（单的AOE）、AOE；近战（近的远）、远程；瞬发、吟唱；一次瞬间结算、持续伤害、多次瞬间伤害（多次一次）；敌方、己方、无差别；点选、范围。\n正交设计模式进行正交程序设计、模块耦合度最低；面向对象；重构；需求分析；抽象；接口设计\n\n 放一个火球\n FlyObject\n 最原始的SkillSampleFireBall\n 技能基础框架2（TimeLine）\n 技能配置表\n 技能基础框架（SkillMgr，SkillCaster）\n\n时间线\n技能不同时释放\n放技能时不移动，不响应其他活动\n\n 瞬间伤害技能\n AOE技能\n SkillLogic动态实例化（反射）\n\n 施法范围限定\n 技能伤害\n 伤害数值配置\n 属性变化监听\n 与服务器对接实战\n异步通信搭建服务器\nC#子线程执行完后，利用委托调用主线程的方法\n Npc分类，功能Npc和怪物Npc\n 自动选择目标\n 持续性伤害结算\n持续n秒，走进区域的敌人，收到伤害；\n对半径为R的区域每秒造成伤害，持续n秒\n 辅助追踪目标\n Npc攻击主角\n 角色状态控制\n 死亡与重生\n 技能CD\n\nPS.\n 推波技能\n 定制技能（扩展时间线）\n 通用提示框\n 小地图\n 道具拾取\n 背包系统\n 任务系统\n 装备\n 坐骑\n","categories":["游戏引擎","Unity"],"tags":["软件工程"]},{"title":"github+hexo搭建博客（附带美化教程链接）","url":"/2020/07/03/github+hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E9%99%84%E5%B8%A6%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B%E9%93%BE%E6%8E%A5%EF%BC%89/","content":"贴上大佬们详细的教程!\nPs.\nHexo官网\nHexo中文官网\nButterfly主题\n转载- 手把手教你搭建属于自己的hexo+github博客\n转载-【源码开放】Hexo+Github 博客butterfly 和 matery 主题 搭建完全教程【整理】\n转载- hexo文章中添加本地图片不显示 \n","categories":["杂项"],"tags":["hexo"]},{"title":"Docker安装MySQL5.6","url":"/2020/07/03/Docker%E5%AE%89%E8%A3%85MySQL5-6/","content":"1,docker hub上查找mysql镜像\ndocker search mysql\n2,在dockerhub上（阿里云加速器）拉取MySQL镜像到本地标签为5.6\ndocker pull mysql:5.6\n3,使用mysql5.6创建容器（也叫运行镜像）\ndocker run -p 12345:3306 --name mysql -v /zycmysql/conf:/etc/mysql/conf.d -v /zymysql/mysql/logs -v /zycmsql/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n基本启动（缺点：容器关闭在启动我们的数据就没有了）\n# docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n高级启动（容器关闭在启动我么你的数据不会消失）\n# docker run --name mysql -p 3306:3306 -v /mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n4,交互运行，进入mysql\n#  docker exec -it adca2afca208 /bin/bashmysql -uroot -pshow databases;\n5,查看服务器地址\nifconfig\n","categories":["Docker"],"tags":["Linux","运维"]},{"title":"Docker安装gitlab并简单实用","url":"/2020/07/03/Docker%E5%AE%89%E8%A3%85gitlab%E5%B9%B6%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/","content":" 前言\n\n系统 centos7.*\n通过docker 安装gitlab 并 持久化\n\n 下载镜像\n    执行下面的命令，从 docker 的镜像仓库中下载 gitlab 社区版的镜像\ndocker pull gitlab/gitlab-ce:latest\n 编写docker-compose文件\nversion: &#x27;2&#x27;services:    gitlab:      image: &#x27;gitlab/gitlab-ce:latest&#x27;      restart: unless-stopped      hostname: &#x27;192.168.124.72&#x27;      environment:        TZ: &#x27;Asia/Shanghai&#x27;        GITLAB_OMNIBUS_CONFIG: |          external_url &#x27;http://192.168.124.72&#x27;          gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;          # 需要配置到 gitlab.rb 中的配置可以在这里配置，每个配置一行，注意缩进。          # 比如下面的电子邮件的配置：          # gitlab_rails[&#x27;smtp_enable&#x27;] = true          # gitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.exmail.qq.com&quot;          # gitlab_rails[&#x27;smtp_port&#x27;] = 465          # gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;xxxx@xx.com&quot;          # gitlab_rails[&#x27;smtp_password&#x27;] = &quot;password&quot;          # gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;          # gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = true          # gitlab_rails[&#x27;smtp_tls&#x27;] = true          # gitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;xxxx@xx.com&#x27;      ports:        - &#x27;80:80&#x27;        - &#x27;443:443&#x27;        - &#x27;222:22&#x27;      volumes:        - ./gitlab/config:/etc/gitlab        - ./gitlab/data:/var/opt/gitlab        - ./gitlab/logs:/var/log/gitlabvolumes:    config:    data:    logs:\n    启动\ndocker-compose up -d\n    修改配置文件\n# 配置http协议所使用的访问地址external_url &#x27;http://192.168.124.72&#x27;# 配置ssh协议所使用的访问地址和端口gitlab_rails[&#x27;gitlab_ssh_host&#x27;] = &#x27;192.168.124.72&#x27;gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 222\n    注意，每次修改gitlab.rb配置文件之后，或者在容器里执行gitlab-ctl reconfigure命令，或者重启容器以让新配置生效。\n","categories":["Docker"],"tags":["运维","gitlab"]},{"title":"在CeontOS中安装Docker","url":"/2020/07/03/%E5%9C%A8CeontOS%E4%B8%AD%E5%AE%89%E8%A3%85Docker/","content":"    前提条件：首先我们安装的不是企业版。企业版提供了有一些收费的高级特性，社区版没有这些特性，但是不影响我们目前的使用。\n centos7修改yum源为阿里源\n 安装base reop源\n# cd /etc/yum.repos.d/\n    接着备份旧的配置文件\n# sudo mv CentOS-Base.repo CentOS-Base.repo.bak\n    下载阿里源的文件\n# sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n 安装epel repo源\n    epel（RHEL7）\n# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo\n    epel（RHEL6）\n# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo\n    epel（RHEL5）\n# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-5.repo\n 清理缓存\n# yum clean all\n 重新生成缓存\n# yum makecache\n CentOS7安装dockerCE\n 卸载旧版本\n    如果是新机器可以忽略这一步，因为centos还没有自带docker服务。\n# yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotatedocker-selinux docker-engine-selinux docker-engine\n 安装dockerCE\n\n安装依赖包\n\n# yum install -y yum-utils device-mapper-persistent-data lvm2\n\n添加Docker软件包源\n\n# yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n    但是鉴于国内网络问题，建议使用国内阿里的源\n# yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n 打开测试版本list\n    如果你希望安装测试版本和edge版本，但默认情况下处于禁用状态。可以将它们与稳定存储库一起启用\n# yum-config-manager --enable docker-ce-edge# yum-config-manager --enable docker-ce-test\n 安装（安装最新版本）\n# yum install docker-ce\n 安装（制定版本）\n# yum list docker-ce --showduplicates|sort –r# yum install docker-ce-17.06.0.ce\n 启动\n启动        systemctl start docker\n守护进程重启   sudo systemctl daemon-reload\n重启docker服务   systemctl restart  docker\n重启docker服务  sudo service docker restart\n关闭docker   service docker stop\n关闭docker  systemctl stop docker\n 更换docker源\nsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://172ih0ly.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker\n","categories":["Docker"],"tags":["运维"]},{"title":"震惊！Ctfmon无法启动 任务栏输入法图标消失竟然是因为这个！","url":"/2020/07/03/%E9%9C%87%E6%83%8A%EF%BC%81Ctfmon%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8-%E4%BB%BB%E5%8A%A1%E6%A0%8F%E8%BE%93%E5%85%A5%E6%B3%95%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E7%AB%9F%E7%84%B6%E6%98%AF%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%B8%AA%EF%BC%81/","content":" 前言\n    废话不多说，打算拿出我的数位板画几个小人，结果劳资的噩梦就来了…\n    首先我买的是高漫的便宜的板子，驱动是第三方下的旧版本驱动（吐槽一下官网最新的驱动，永远都是未连接设备）一切搞定后，试了试压感，调了笔，没有问题后我习惯性的重启一下电脑！\n 问题\n    问题来了，再开机的时候任务栏的输入法没了，谷歌和文本文档都无法使用中文，无法切换输入法了。\n    我一开始以为是中文语言的问题，排查之后莫得问题啊，然后我就开始了疯狂的百度，介绍的方法全都试了一遍，全都不行。\n    然后我又看了启动项，ctfmon启动—没问题，详细信息寻找ctfmon？？？竟然木有ctfmon…\n    最后确定问题在于ctfmon没有正常启动…\n 解决\n    所以现在问题就变成了如何启动ctfmon，我试过手动启动ctfmon，不行！修改注册表，不行！再修改注册表启动项还是不行！\n    就在我即将放弃的时候，我终于看到了贴吧一个大佬的提问“你们的win10有ctfmon.exe这个进程吗？”\n    我一瞬间感到一丝希望，顺着看下去\n    “我的解决方案：在任务计划板里找到     TextServicesFramework   这个，然后禁用掉就好啦，你们要是和我前提情况一样可以试试哦“\n    “当时我和我同学的电脑做了对比，最终我发现，他的tsf是 准备状态，我的则是运行中，我就干脆禁用掉，然后发现可行，我就赶紧来这发帖了”\n    正如我所见到一样，感谢大佬，不得不说，大佬是怎么想到呢！厉害了！\n    PS.不是很放心我就去百度了一下TSF的作用，貌似还是有点用的，后续有问题再解决吧！\n","categories":["杂项"],"tags":["Windows"]},{"title":"CentOS设置笔记本合盖不休眠","url":"/2020/07/03/CentOS%E8%AE%BE%E7%BD%AE%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%90%88%E7%9B%96%E4%B8%8D%E4%BC%91%E7%9C%A0/","content":" 前言\n    本来想在虚拟机里面装环境搞一搞事情，折腾完发现，虚拟机要一直开机真的很不方便，突然想起来我还有一台老旧笔记本。索性照着虚拟机把这个老旧的笔记本变成服务器算了。\n    折腾了一圈终于搞成了，但是屏幕，键盘总亮着，笔记本总张开着，还是不够方便。\n    so，就有了这篇记录\n 操作\n 配置文件\n    配置CentOS7的合上笔记本的行为响应的文件，目录为：/etc/systemd/logind.conf\nvim /etc/systemd/logind.conf\n 修改配置\n    配置文件中修改项有很多，主要看这三个\nHandlePowerKey 按下电源键后的行为，默认power offHandleSleepKey 按下挂起键后的行为，默认suspendHandleHibernateKey 按下休眠键后的行为，默认hibernateHandleLidSwitch 合上笔记本盖后的行为，默认suspend\n    我们需要把HandleLidSwitch后面的suspend修改为lock，这样合上笔记本盖子的时候就会变成锁屏状态，计算机继续工作，而不是挂起。\nPS.默认logind.conf文件中基本上都被注释掉了，记得去掉注释。\n    使用如下命令使配置生效\nsystemctl restart systemd-logind\nignore 忽略，跳过power off 关机eboot 重启halt 挂起suspend shell内建指令，可暂停目前正在执行的shell。若要恢复，则必须使用SIGCONT信息。所有的进程都会暂停，但不是消失（halt是进程关闭）hibernate 让笔记本进入休眠状态hybrid-sleep 混合睡眠，主要是为台式机设计的，是睡眠和休眠的结合体，当你选择Hybird时，系统会像休眠一样把内存里的数据从头到尾复制到硬盘里 ，然后进入睡眠状态，即内存和CPU还是活动的，其他设置不活动，这样你想用电脑时就可以快速恢复到之前的状态了，笔记本一般不用这个功能。lock 仅锁屏，计算机继续工作。\n","categories":["杂项"],"tags":["Centos"]},{"title":"Unity网络通同步工具-Photo","url":"/2020/07/03/Photon%E6%95%99%E7%A8%8B/","content":" 申请photon账号\n 申请游戏appid\n 申请登录中国区Photoncloud服务器\n 下载安装PUN2\n    在Unity中新建项目并下载安装PUN2.设置PhotonServerSettings中Setting  的AppId\n 修改Photon的配置使程序可以使用中国区Photon cloud\n 在loadBalancingClient.cs找到NameServerHost\n 将国外域名改为国内域名\n    将public string NameServerHost = “ns.exitgames.com”;改为&quot;ns.photonengine.cn&quot;\n 在\\Assets\\Photon\\PhotonUnityNetworking\\Resources中找到PhotonServerSettings\n 在setting中将FixedRegion改为cn\n 建立登陆场景Start并测试是否可以登录Photoncloud\n 建立UI button，文本“联机游戏”\n Create Empty 并改名NetworkManager\n 建立NetworkManager.cs并加载到NetworkManager\n 修改NetworkManager.cs 并测试联网\nusing System.Collections;using System.Collections.Generic;using UnityEngine;//导入 using Photon.Pun;using Photon.Realtime;public class NetworkManager : MonoBehaviourPunCallbacks //修改为MonoBehaviourPunCallbacks&#123;    //---------------------------连接---------------------------------//    public void Connect()    &#123;        if (PhotonNetwork.IsConnected) //如果已经连接 Photon cloud        &#123;            //进入房间，开始游戏            PhotonNetwork.JoinRandomRoom();        &#125;        else//如果没有连接 Photon cloud        &#123;            //取消离线模式            PhotonNetwork.OfflineMode = false;            //玩家名称 PhotonNetwork.NickName = &quot;Player&quot;;            //游戏版本 PhotonNetwork.GameVersion = gameVersion;            //开始连接            PhotonNetwork.ConnectUsingSettings();        &#125;            &#125;    //---------------------连接master回调函数---------------------------    public override void OnConnectedToMaster()    &#123;        Debug.Log(&quot;PUNBasicsTutorial/Launcher:OnConnectedToMaster() was called by PUN&quot;);        Debug.Log(&quot;--------------连接成功！--------------&quot;);        //加入随机room        PhotonNetwork.JoinRandomRoom();    &#125;    public override void OnDisconnected(DisconnectCause cause)    &#123;        Debug.LogWarningFormat(&quot;PunEvent Basics Tutorial/Launcher:OnDisconnected() was called by PUN with reason&#123;0&#125;&quot;,cause);        Debug.Log(&quot;--------------断开连接！--------------&quot;);    &#125;    //-----------------加入Room回调函数---------------------------    public override void OnJoinRandomFailed(short returnCode, string message)    &#123;        Debug.Log(&quot;&quot;);        Debug.Log(&quot;--------------加入房间失败！-----------------&quot;);        Debug.Log(&quot;--------------建立新房间!-------------------&quot;);        PhotonNetwork.CreateRoom(null, new RoomOptions&#123; MaxPlayers = 8&#125;);    &#125;    public override void OnJoinedRoom()    &#123;        Debug.Log(&quot;&quot;);        Debug.Log(&quot;---------加入Room成功！&quot;);        //Load 一个游戏场景        PhotonNetwork.LoadLevel(&quot;GameLevel1&quot;);    &#125;&#125;\n 建立单机游戏场景 GameLevel1\n略\n 将单机游戏场景改为多人联网游戏\n\n\n建立游戏场景管理者\n\n\n建立游戏资源文件夹保存需要同步的player和子弹bullet 为prefab\nPS.注意，一定要放在asset下的Resources文件下\n\n\nplaye prefab 加载 PhotonView组件\n\n\n将player的Transform拖到Photon View上\n\n\nbullet prefab 加载 PhotonView组件\n\n\n将bullet 的Transform拖到Photon View上\n\n\n判断是否本机玩家\n\n\nusing Photon.Pun;public class PlayerController : MonoBehaviourPun //改为MonoBehaviourPun...//检测是否本机玩家 ,如果不是，不做控制        if(photonView.IsMine == false &amp;&amp; PhotonNetwork.IsConnected == true)        &#123;            return;        &#125;\n\n为敌人添加Photon view组件，并同步位置\n使用Photon的PhotonNetwork.Instantiate方法同步生成子弹对象\n使用Photon的PhotonNetwork.Destory方法同步销毁子弹对象\n\nusing Photon.Pun;public class bulletMove:MonoBehaviiourPun&#123;...PhotonNetwork.Destory(gameobject);\n\n在生成敌人时判断玩家是否是主玩家或者采用单例模式 避免重复生成敌人\n\nif(PhotonNetwork.IsMasterClient)//玩家是不是master&#123;&#125;\n 开始游戏\n 方法类\n","categories":["游戏引擎","Unity","Photon"],"tags":["Photon"]},{"title":"markdown中数学公式编辑参考","url":"/2020/07/03/markdown%E4%B8%AD%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%8F%82%E8%80%83/","content":" 数学公式和符号\n 行内公式和行间公式\n    行内公式是在公式代码块的基础上前面加上$ ，后面加上$组成的，行间公式则是在公式代码块前后使用$$ 和$$ 。\n\n行内公式：Γ(z)=∫0∞tz−1e−tdt .\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.Γ(z)=∫0∞​tz−1e−tdt.\n行间公式：\n\nΓ(z)=∫0∞tz−1e−tdt .\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\nΓ(z)=∫0∞​tz−1e−tdt.\n代码块：\n* 行内公式：$\\Gamma(z) = \\int_0^\\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\\,.$* 行间公式：$$\\Gamma(z) = \\int_0^\\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\\,.$$\n 希腊字母\n\n\n\n名称\n大写\ncode\n小写\ncode\n\n\n\n\nalpha\nA\nA\nα\n\\alpha\n\n\nbeta\nB\nB\nβ\n\\beta\n\n\ngamma\nΓ\n\\Gamma\nγ\n\\gamma\n\n\ndelta\nΔ\n\\Delta\nδ\n\\delta\n\n\nepsilon\nE\nE\nϵ\n\\epsilon\n\n\nzeta\nZ\nZ\nζ\n\\zeta\n\n\neta\nH\nH\nη\n\\eta\n\n\ntheta\nΘ\n\\Theta\nθ\n\\theta\n\n\niota\nI\nI\nι\n\\iota\n\n\nkappa\nK\nK\nκ\n\\kappa\n\n\nlambda\nΛ\n\\Lambda\nλ\n\\lambda\n\n\nmu\nM\nM\nμ\n\\mu\n\n\nnu\nN\nN\nν\n\\nu\n\n\nxi\nΞ\n\\Xi\nξ\n\\xi\n\n\nomicron\nO\nO\nο\n\\omicron\n\n\npi\nΠ\n\\Pi\nπ\n\\pi\n\n\nrho\nP\nP\nρ\n\\rho\n\n\nsigma\nΣ\n\\Sigma\nσ\n\\sigma\n\n\ntau\nT\nT\nτ\n\\tau\n\n\nupsilon\nΥ\nY\nυ\n\\upsilon\n\n\nphi\nΦ\n\\Phi\nϕ\n\\phi\n\n\nchi\nX\nX\nχ\n\\chi\n\n\npsi\nΨ\n\\Psi\nψ\n\\psi\n\n\nomega\nΩ\n\\Omega\nω\n\\omega\n\n\n\n 上标与下标\n    上标和下标分别使用^ 与_ ，例如$x_i^2$表示的是：xi2x_i^2xi2​。\n    默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用&#123;..&#125; 包裹起来的内容。如果使用$10^10$ 表示的是101010^101010，而$10^&#123;10&#125;$ 才是101010^{10}1010。同时，大括号还能消除二义性，如x^5^6 将得到一个错误，必须使用大括号来界定^的结合性，如$&#123;x^5&#125;^6$：x56{x^5}^6x56或者$x^&#123;5^6&#125;$ ：x56x^{5^6}x56。\n 括号\n 小括号与方括号\n    使用原始的( ) ，[ ] 即可，如$(2+3)[4+4]$ ： (2+3)[4+4](2+3)[4+4](2+3)[4+4]\n    使用\\left(或\\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如$\\left(\\frac&#123;x&#125;&#123;y&#125;\\right)$ ：(xy)\\left(\\frac{x}{y}\\right)(yx​)\n 大括号\n    由于大括号&#123;&#125; 被用于分组，因此需要使用\\&#123;和\\&#125;表示大括号，也可以使用\\lbrace 和\\rbrace来表示。如$\\&#123;a\\*b\\&#125;:a\\∗b$ 或$\\lbrace a\\*b\\rbrace :a\\*b$ 表示\\{a\\*b\\}:a\\∗b。\n 尖括号\n    区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如$\\langle x \\rangle$ 表示：⟨x⟩\\langle x \\rangle⟨x⟩。\n 上取整\n    使用\\lceil 和 \\rceil 表示。 如，$\\lceil x \\rceil$：⌈x⌉\\lceil x \\rceil⌈x⌉。\n 下取整\n    使用\\lfloor 和 \\rfloor 表示。如，$\\lfloor x \\rfloor$：⌊x⌋\\lfloor x \\rfloor⌊x⌋。\n 求和与积分\n 求和\n    \\sum 用来表示求和符号，其下标表示求和下限，上标表示上限。如:\n    $\\sum_&#123;r=1&#125;^n$表示：∑r=1n\\sum_{r=1}^n∑r=1n​。\n    $$\\sum_&#123;r=1&#125;^n$$表示：$$\\sum_{r=1}^n$$\n 积分\n    \\int 用来表示积分符号，同样地，其上下标表示积分的上下限。如，$\\int_&#123;r=1&#125;^\\infty$：∫r=1∞\\int_{r=1}^\\infty∫r=1∞​。\n  多重积分同样使用 int ，通过 i 的数量表示积分导数：\n  $\\iint$ ： ∬\\iint∬\n  $\\iiint$ ：∭\\iiint∭\n  $\\iiiint$ ： \\iiiint\n 连乘\n    $\\prod &#123;a+b&#125;$，输出：∏a+b\\prod {a+b}∏a+b。\n    $\\prod_&#123;i=1&#125;^&#123;K&#125;$，输出：∏i=1K\\prod_{i=1}^{K}∏i=1K​。\n    $$\\prod_&#123;i=1&#125;^&#123;K&#125;$$，输出：$$\\prod_{i=1}^{K}$$。\n 其他\n与此类似的符号还有，\n    $\\prod$ ：∏\\prod∏\n    $\\bigcup$ ：⋃\\bigcup⋃\n    $\\bigcap$ ：⋂\\bigcap⋂\n    $arg\\,\\max_&#123;c_k&#125;$：arg max⁡ckarg\\,\\max_{c_k}argmaxck​​\n    $arg\\,\\min_&#123;c_k&#125;$：arg min⁡ckarg\\,\\min_{c_k}argminck​​\n    $\\mathop &#123;argmin&#125;_&#123;c_k&#125;$：argminck\\mathop {argmin}_{c_k}argminck​​\n     $\\mathop &#123;argmax&#125;_&#123;c_k&#125;$：argmaxck\\mathop {argmax}_{c_k}argmaxck​​\n    $\\max_&#123;c_k&#125;$： max⁡ck\\max_{c_k}maxck​​\n    $\\min_&#123;c_k&#125;$： min⁡ck\\min_{c_k}minck​​\n 分式与根式\n 分式\n\n第一种，使用\\frac ab，\\frac作用于其后的两个组a ，b ，结果为ab\\frac abba​。如果你的分子或分母不是单个字符，请使用{…}来分组，比如$\\frac &#123;a+c+1&#125;&#123;b+c+2&#125;$表示a+c+1b+c+2\\frac {a+c+1}{b+c+2}b+c+2a+c+1​。\n第二种，使用\\over来分隔一个组的前后两部分，如$&#123;a+1\\over b+1&#125;$：a+1b+1{a+1\\over b+1}b+1a+1​\n\n 连分数\n    \n 根式\n    \n 多行表达式\n    \n 分类表达式\n    \n 多行表达式\n    \n 方程组\n    \n 特殊函数与符号\n    \n 三角函数\n    \n 比较函数\n    \n 集合关系与运算\n    \n 排列\n    \n 箭头\n    \n 逻辑运算符\n    \n 操作符\n    \n 等于\n    \n 范围\n    \n 模运算\n    \n 点\n    \n 顶部符号\n    对于单字符，\\hat x ：x^\\hat xx^\n    多字符可以使用\\widehat {xy} ：xy^\\widehat {xy}xy​\n    (\\overline x ): x‾\\overline xx\n    矢量(\\vec x): x⃗\\vec xx\n    向量(\\overrightarrow {xy} ):xy→\\overrightarrow {xy}xy​\n    (\\dot x ): x˙\\dot xx˙\n    (\\ddot x ):x¨\\ddot xx¨\n    (\\dot {\\dot x} ):x˙˙\\dot{\\dot x}x˙˙\n 表格\n    \n 矩阵\n    \n 基本内容\n    \n 括号\n    \n 元素省略\n    \n 增广矩阵\n    \n 公式标记与引用\n    \n 字体\n    \n","categories":["杂项"],"tags":["math","latex"]}]